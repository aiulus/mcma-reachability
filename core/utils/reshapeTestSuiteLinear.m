function ts_out = reshapeTestSuiteLinear(ts_in, sys)
% reshapeTestSuiteLinear - Reshapes a 'flattened' test suite for linear
% systems back to the standard multi-testCase format.
%
% Syntax:
%    ts_out = reshapeTestSuiteLinear(ts_in, sys)
%
% Description:
%    The 'createTestSuite' function generates test suites in a "flattened"
%    format for 'linearSysDT' and 'linearARX' systems. This means all
%    trajectories (n_m * n_s) are concatenated into a single testCase
%    object within a 1x1 cell array. This utility function reverses that
%    process. It takes the flattened test suite and reshapes it into a
%    (n_m x 1) cell array, where each cell contains a testCase object
%    with its corresponding (n_s) simulation outputs, nominal input, and
%    nominal initial state.
%
%    The function automatically deduces the original number of test cases
%    (n_m) and simulations per case (n_s) by inspecting the structure of
%    the repeated nominal input trajectories in the flattened data.
%
% Inputs:
%    ts_in - A 1x1 cell array containing a single testCase object, as
%            generated by createTestSuite for a linear system.
%    sys   - The system object (e.g., linearSysDT) used to generate ts_in.
%            This argument is kept for signature consistency but the
%            function primarily operates on ts_in.
%
% Outputs:
%    ts_out - An (n_m x 1) cell array of testCase objects, where each
%             object holds the data for one test case (y-data of size
%             [n_k, dim_y, n_s], nominal u-data of size [n_k, dim_u],
%             and nominal x0-data of size [dim_x, 1]).
%
% See also: createTestSuite, testCase

% --- 1. Input Validation and Data Extraction ---
if ~iscell(ts_in) || numel(ts_in) ~= 1
    error('Input ts_in must be a 1x1 cell array containing a single testCase object.');
end

tc_flat = ts_in{1};
if ~isa(tc_flat, 'testCase')
    error('The cell ts_in{1} must contain a valid testCase object.');
end

% Extract the flattened data arrays
y_flat = tc_flat.y;
u_flat = tc_flat.u;
x0_flat = tc_flat.initialState;
dt = sys.dt;
sysClass = class(sys);

% Get total number of trajectories
N_total = size(y_flat, 3);

if N_total == 0
    ts_out = {}; % Handle empty test suite
    return;
end

% --- 2. Deduce n_s and n_m ---
% The flattened test suite repeats the nominal input u_m for each of the
% n_s simulations within a test case. We can find n_s by counting how
% many initial trajectories in u_flat are identical.

u_first = u_flat(:,:,1);
n_s = 1;
for i = 2:N_total
    if isequal(u_flat(:,:,i), u_first)
        n_s = n_s + 1;
    else
        break; % Found a different nominal input, so the block of n_s ends here
    end
end

% Calculate n_m and check for consistency
if mod(N_total, n_s) ~= 0
    error(['Inconsistent test suite structure. Total trajectories (%d) ', ...
           'is not divisible by the detected number of simulations per case (n_s = %d).'], ...
           N_total, n_s);
end
n_m = N_total / n_s;


% --- 3. Reshape the data and create the output test suite ---
ts_out = cell(n_m, 1);

for m = 1:n_m
    % Calculate the start and end indices for the m-th test case block
    start_idx = (m - 1) * n_s + 1;
    end_idx = m * n_s;
    
    % Extract the y-trajectories for this test case (all n_s simulations)
    % Shape: (n_k, dim_y, n_s)
    y_m = y_flat(:, :, start_idx:end_idx);
    
    % Extract the nominal input trajectory for this test case.
    % It's the first one in the block (and identical for all n_s).
    % Shape: (n_k, dim_u)
    u_m = u_flat(:, :, start_idx);
    
    % Extract the nominal initial state for this test case.
    % It's the first one in the block (and identical for all n_s).
    % Shape: (dim_x, 1)
    x0_m = x0_flat(:, :, start_idx);
    
    % Create the new testCase object and add it to the output cell array
    ts_out{m} = testCase(y_m, u_m, x0_m, dt, sysClass);
end

end
